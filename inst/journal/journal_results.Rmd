---
title: 'Active Surveillance Progression Prediction'
author: 'Stefan Eng'
output:
  bookdown::pdf_document2:
    keep_tex: true
  html_notebook: default
bibliography:  bibliography.bib
csl: european-urology.csl
nocite: |
  @BPG
---

```{r setup, include=FALSE}
library(BoutrosLab.ASBiomarkerSynergy);
library(survival);
library(BoutrosLab.plotting.general);
library(flextable);
library(magrittr);
library(pROC);
library(caret);
library(here);
library(gtsummary);

knitr::opts_chunk$set(echo = FALSE, warning = FALSE, fig.align = 'center', out.width = '60%', fig.pos = 'H');

#axis.cex <- .7
#lab.cex <- .8
strip.cex <- 0.45

as.data <- default.load.data();
biodb <- as.data$biodb;

biomarkers <- load.biomarker.categories()

biomarkers.clinically.useful <- biomarkers[biomarkers$clinically.useful == 1,]

valid.patients <- biodb$NoUpgradeAndProgressed == 0 | is.na(biodb$NoUpgradeAndProgressed);

biodb.valid <- biodb[valid.patients, ];

col.labels <- label.or.name(biodb)
names(col.labels) <- colnames(biodb)
```

## Demographcs

```{r bx-biomarker-summary}
demo.vars <- c(
            'Age',
            'BMI',
            'Race',
            'Ethnicity',
            'ProstateVolume',
            'SOCPSA',
            'PCA3',
            'T2ERG',
            'MiPSCancerRisk',
            'PercentFreePSA',
            'PHI',
            'GeneticRiskScore',
            'RSIlesionSignal',
            'RSIlesionPIRADS',
            'PSADensity',
            'PHIDensity'
            );

demo.vars <- c(
  "Age",
  "Race",
  "Ethnicity",
  "Weight",
  "Height",
  "BMI",
  "SOCPSA",
  "PSADensity", 
  "freePSA", "p2PSA", "PercentFreePSA", "PHI", "PHIDensity",
  "MRIResult", "MRILesions",
  "BiopsyResult",
  "ProstateVolume",
  "PreviousISUP",
  "StudyHighestISUP",
  "PCA3", "T2ERG", "MiPSCancerRisk",
  "GeneticRiskScore",
  "TNFaAverage",
  "RSInormalSignal",
  "RSIlesionSignal",
  "ADCnormalSignal",
  "ADClesionSignal",
  "RSIlesionPIRADS",
  "Germline_variants",
  "FollowUpTime"
)

target.vars <- c("ProgressedToTreatment", "Prostatectomy")

demo.table <- tbl_summary(data = biodb[, c(demo.vars, 'BiopsyUpgraded')],
  by = BiopsyUpgraded,
  missing = "no",
  label = RSIlesionPIRADS ~ 'RSI lesion PI-RADS') %>%
  add_p() 

# demo.metadata <- demo.table$meta_data

target.table <- tbl_summary(data = biodb[, c(target.vars, 'BiopsyUpgraded')],
  by = BiopsyUpgraded,
  missing = "no")
  
all.demo.table <- tbl_stack(list(demo.table, target.table)) %>%
  bold_labels() %>%
  modify_spanning_header(c("stat_1", "stat_2") ~ "**Grade Group Upgrade**")

all.demo.table

flextable::save_as_docx(as_flex_table(all.demo.table), path = here::here('euro_urology/tables/demographics.docx'))
```

## Correlation heatmap
```{r}
create.heatmap.AS(biodb, filename = here('euro_urology/figures/corr_multiplot.tiff'), resolution = 300)
```

## Models

```{r, cache = TRUE}
seed <- 1313;
targets <- c(
    'BiopsyUpgraded',
    #'Prostatectomy',
    'ProgressedToTreatment'
    );
metric <- 'PR-AUC';
method <- 'gbm';
model.names <- c('everything', 'reduced_both', 'reduced_only_RSIlesionSignal', 'reduced_only_RSIlesionPIRADS');
model.nice.names <- c(
  'Full Model',
  'CR + RSI lesion signal and PI-RADS',
  'CR + RSI lesion signal',
  'CR + PI-RADS'
)
models <- lapply(targets, function(x) {
    model.id <- paste(x, metric, seed, sep = "_");
    model.id <- paste(model.id, model.names, sep = "_");
  
    model.files <- here(paste('models/gbm', model.id, 'model.RDS', sep = "_"));  
    names(model.files) <- model.nice.names;
    lapply(model.files, readRDS);
})
names(models) <- targets;

models.roc <- lapply(models, function(x) {
  lapply(x, function(m) {
      bestPreds <- with(m, merge(pred, bestTune));
      pROC::roc(predictor = bestPreds$yes, response = bestPreds$obs, direction = '<', levels = c('no', 'yes'));
  })
})

optimal.thresholds <- lapply(models.roc, function(rocs) {
  lapply(rocs, function(r) {
      as.numeric(coords(r, 'best')[1])
  })
})
```

## ROC/PR Curves
```{r}
tiff(filename = here('euro_urology/figures/roc-pr_curves.tiff'), width = 10, height = 8, res = 300, units = 'in')
# par(cex = 2)
roc.pr.plot(models.roc$BiopsyUpgraded)
dev.off()
```

## MISC

Cohort (training set) predictions.
```{r}
bx.preds <- rep(NA, nrow(biodb.valid))
bx.preds[!is.na(biodb.valid$BiopsyUpgraded)] <- ifelse(predict(models$BiopsyUpgraded$`Full Model`, type = 'prob')[, 'yes'] > optimal.thresholds$BiopsyUpgraded$`Full Model`, 1, 0)

bx.preds.factor <- as.factor(bx.preds)
levels(bx.preds.factor) <- c('no', 'yes')

bx.reduced.preds <- rep(NA, nrow(biodb.valid))
bx.reduced.preds[!is.na(biodb.valid$BiopsyUpgraded)] <- ifelse(predict(models$BiopsyUpgraded$`CR + RSI lesion signal`, type = 'prob')[, 'yes'] > optimal.thresholds$BiopsyUpgraded$`Full Model`, 1, 0)

bx.reduced.preds.factor <- as.factor(bx.reduced.preds)
levels(bx.reduced.preds.factor) <- c('no', 'yes')

confusionMatrix(bx.preds.factor, biodb.valid$BiopsyUpgraded)
confusionMatrix(bx.reduced.preds.factor, biodb.valid$BiopsyUpgraded)
```

```{r summary-table-bx}
summary.df <- summarize.models(models['BiopsyUpgraded'], models.roc['BiopsyUpgraded'])
cols <- c("model", "Accuracy", "Sensitivity", "Specificity", "Precision", "F1")

thresholds.table <- summary.df[, cols]
# Break camel case into newlines
# thresholds.table$target <- kableExtra::linebreak(camel.to.spaces(thresholds.table$target, replace = "\n"), align = "c")
num.cols <- 2:length(cols)
thresholds.table[, num.cols] <- lapply(thresholds.table[, num.cols], function(x) round(as.numeric(x), 2))

(upgrade.table <- flextable(thresholds.table) %>%
  add_footer_lines('CR = Clinically relevant variables') %>%
  # set_caption('Models comparison between the full model, and clinically relevant models with RSI lesion signal and PI-RADS. Including RSI lesion signal improves the model greatly while adding RSI PI-RADS does not have much effect if RSI lesion signal is in the model. All of the statistics are over the cross-validation 10-folds and 5 repetitions (N = 480).') %>%
  autofit())

save_as_docx(upgrade.table, path = here('euro_urology/tables/upgrade_table.docx'))
```

```{r variable-importance}
bx.upgrade.var.imp <- var.imp.combine(models$BiopsyUpgraded, order = TRUE)

flextable(bx.upgrade.var.imp[order(bx.upgrade.var.imp[,2], decreasing = TRUE), ], )
```

## Sequential Models

```{r}
group.tests <- FALSE

if(group.tests) {
  seq.model.index <- c(1,4,5,6);
} else {
  seq.model.index <- 1:6
}

seq.model.id <- paste('sequential6', 'BiopsyUpgraded', metric, seed, sep = '_');
seq.model.file <- paste(seq.model.id, seq.model.index, 'model.RDS', sep = '_');
seq.model.path <- here::here(paste0('models/sequential/', seq.model.file));

seq.models <- lapply(seq.model.path, readRDS);

if(group.tests) {
  names(seq.models) <- c('Demographics', 'Blood, Urine, Genetics', 'MRI Features', 'Volume Corrected');
} else {
  names(seq.models) <- c('Demographics', 'Blood', 'Urine', 'Genetics', 'MRI Features', 'Volume Corrected');
}


seq.models.roc <- lapply(seq.models, function(m) {
    bestPreds <- with(m, merge(pred, bestTune));
    pROC::roc(predictor = bestPreds$yes, response = bestPreds$obs, direction = '<', levels = c('no', 'yes'));
})

best.thres <- lapply(seq.models.roc, function(x) {
  as.numeric(coords(x, 'best', transpose = TRUE)[1])
})
```

```{r}
summary.df <- summarize.seq.models(seq.models, seq.models.roc)
metrics <- c("Accuracy", "Sensitivity", "Specificity", "Precision", "F1")
cols <- c("group", metrics)

seq.var.names <- lapply(seq.models, function(x) x$finalModel$var.names)
all.var.names <- unique(unlist(seq.var.names))

thresholds.table <- summary.df[, cols]
thresholds.table$group <- lapply(seq_along(seq.models), function(i) {
  paste0(names(seq.models)[1:i], collapse = " +\n")
})

thresholds.table[, 2:ncol(thresholds.table)] <- round(thresholds.table[, 2:ncol(thresholds.table)], digits = 2)
(seq.table <- flextable(thresholds.table) %>%
    width(~ group, width = 2) %>%
    width(~ Accuracy + Sensitivity + Specificity + Precision + F1, width = 1))

save_as_docx(seq.table, path = here('euro_urology/tables/seq_table.docx'))

# TODO: Pull into own function
# Create the dotmap
dotmap.data <- matrix(0, ncol = length(seq.models), nrow = length(all.var.names))
colnames(dotmap.data) <- 1:length(seq.models)
rownames(dotmap.data) <- all.var.names

for(i in seq_along(seq.models)) {
  dotmap.data[seq.var.names[[i]], i] <- 1
}

rownames(dotmap.data) <- col.labels[all.var.names]

var.categories <- factor(biomarkers.clinically.useful$category, levels = unique(biomarkers.clinically.useful$category))

dotmap.bg.data <- as.data.frame(matrix(rep(var.categories, 6), nrow = length(biomarkers.clinically.useful$category), ncol = 6))

dotmap.bg.data <- lapply(dotmap.bg.data, factor, levels = unique(biomarkers.clinically.useful$category))
dotmap.bg.data.int <- data.frame(lapply(dotmap.bg.data, as.numeric))

colnames(dotmap.bg.data.int) <- 1:length(seq.models)
rownames(dotmap.bg.data.int) <- all.var.names

bpg.dotmap <- create.dotmap(
  x = dotmap.data,
  spot.size.function = identity,
  spot.colour.function = function(x) "black",
  colour.scheme = default.colours(nlevels(var.categories), palette.type = 'qual'),
  total.colours = nlevels(var.categories) + 1,
  bg.alpha = 0.65,
  bg.data = dotmap.bg.data.int
)

metric.scatterplot.data <- thresholds.table %>%
  dplyr::mutate(group = 1:length(seq.models)) %>%
  tidyr::gather(metric, value, -group)
# 
metric.colours <- c('dodgerblue', 'goldenrod1', 'darkorange1', 'seagreen2', 'orchid3')
names(metric.colours) <- metrics

metric.scatterplot <- create.scatterplot(
  formula = value ~ group,
  data = metric.scatterplot.data,
  groups = metric.scatterplot.data$metric,
  left.padding = 0,
  xat = seq_along(seq.models),
  col = metric.colours,
  type = 'o',
  add.grid = TRUE,
  # Remove the vertial grid lines
  xgrid.at = 0,
  cex = 2,
  lwd = 4
)

metric.legend <- legend.grob(
    list(
        legend = list(
            colours = metric.colours,
            title = "Metrics",
            labels = metrics,
            border = 'black'
            ),
        legend = list(
            colours = default.colours(nlevels(var.categories), palette.type = 'qual'),
            title = "Test Methodology",
            labels = levels(var.categories),
            border = 'black'
            )
        ),
    title.cex = 2,
    label.cex = 2,
    title.just = 'left'
    );

create.multiplot(
  plot.objects = list(bpg.dotmap, metric.scatterplot),
  panel.heights = c(1, 1),
  y.relation = 'free',
  left.padding = 30,
  right.padding = 2,
  print.new.legend = TRUE,
  xat = seq_along(seq.models),
  xaxis.labels = seq_along(seq.models),
  xlab.label = 'Sequence Group',
  
  ylab.label = list(
            'Metric Value',
            ''
        ),
  legend = list(
    right = list(fun = metric.legend)),
  height = 12,
  width = 16,
  resolution = 300,
  filename = here('euro_urology/figures/seq_dotmap.tiff')
  )
```

## Time-to-event
```{r cutpoint-days-upgrade-dx, fig.cap='Days to biopsy upgrade from diagnosis for the prediction groups.'}
axis.cex <- 1.3
lab.cex <- 1.6

km.arguments <- list(
  xaxis.cex = axis.cex,
  yaxis.cex = axis.cex,
  xlab.cex = lab.cex,
  ylab.cex = lab.cex,
  show.risktable = TRUE,
  risktable.fontsize = 10,
  key.groups.cex = 1.3,
  key.stats.cex = 1.3,
  key.stats.y.pos = 0.5,
  return.statistics = FALSE,
  digits = 1
  );

upgrade.surv.valid <- do.call(
    what = survival::Surv,
    args = surv.format(biodb.valid$DaysDxToUpgrade, biodb.valid$DaysDxToLastReview)
    );

patient.groups <- as.factor(bx.preds[!is.na(upgrade.surv.valid)]);
levels(patient.groups) <- c('No upgrade prediction', 'Predict upgrade');

survival::survfit(upgrade.surv.valid ~ patient.groups)
summary(survival::survfit(upgrade.surv.valid ~ patient.groups))

do.call(
  what = BoutrosLab.plotting.survival::create.km.plot,
  args = c(
    km.arguments,
    list(
      main.cex = 1.75,
      survival.object = upgrade.surv.valid,
      patient.groups = patient.groups,
      main = 'Overall Days-to-Upgrade from Diagnosis',
      xlab.label = 'Days to upgrade since diagnosis',
      ylab.label = 'Upgrade-free survival',
      filename = here('euro_urology/figures/km_dx-to-upgrade.tiff'),
      left.padding = 10,
      risk.label.pos = -1600
      )
    )
  )

upgrade.surv.valid <- do.call(
    what = survival::Surv,
    args = surv.format(biodb.valid$DaysDxToUpgrade, biodb.valid$DaysDxToLastReview)
    );

patient.groups.reduced <- as.factor(bx.reduced.preds[!is.na(upgrade.surv.valid)]);
levels(patient.groups.reduced) <- c('No upgrade prediction', 'Predict upgrade');

survival::survfit(upgrade.surv.valid ~ patient.groups.reduced)
summary(survival::survfit(upgrade.surv.valid ~ patient.groups.reduced))

do.call(
  what = BoutrosLab.plotting.survival::create.km.plot,
  args = c(
    km.arguments,
    list(
      main.cex = 1.75,
      survival.object = upgrade.surv.valid,
      patient.groups = patient.groups.reduced,
      main = 'Overall Days-to-Upgrade from Diagnosis',
      xlab.label = 'Days to upgrade since diagnosis',
      ylab.label = 'Upgrade-free survival',
      filename = here('euro_urology/figures/km_dx-to-upgrade-reduced.tiff')
      )
    )
  )
```

Cross-validated curves. Not really working as intended.
```{r, eval = FALSE}
cv.model.name <- 'CR + RSI lesion signal'
cv.best.preds <- with(models$BiopsyUpgraded[[cv.model.name]], merge(pred, bestTune));
cv.biodb.valid <- biodb.valid[cv.best.preds$rowIndex, ];
  
cv.upgrade.surv.valid <- do.call(
    what = survival::Surv,
    args = surv.format(cv.biodb.valid$DaysDxToUpgrade, cv.biodb.valid$DaysDxToLastReview)
    );

cv.patient.groups <- as.factor(ifelse(cv.best.preds$yes > optimal.thresholds$BiopsyUpgraded[[cv.model.name]], 'yes', 'no'))
levels(cv.patient.groups) <- c('No upgrade prediction', 'Predict upgrade');

survdiff(cv.upgrade.surv.valid ~ cv.patient.groups)
coxph.model <- coxph(cv.upgrade.surv.valid ~ cv.patient.groups)
sum.coxph.model <- summary(coxph.model)

cox.ci <- sum.coxph.model$conf.int[c(1, 3, 4)]
do.call(sprintf, c("%.2f (%.2f, %.2f)", as.list(cox.ci)))
round(sum.coxph.model$waldtest['pvalue'], 3)

do.call(
  what = BoutrosLab.plotting.survival::create.km.plot,
  args = c(
    km.arguments,
    list(
      main.cex = 1.6,
      survival.object = cv.upgrade.surv.valid,
      patient.groups = cv.patient.groups,
      main = 'Overall Days-to-Upgrade from Diagnosis',
      xlab.label = 'Days to upgrade since diagnosis',
      ylab.label = 'Upgrade-free survival',
      ph.assumption.check = "ignore"
      )
    )
  )
```

### TTE Analysis for Progression
```{r cutpoint-days-prog-bx, fig.cap = 'Days to progression from biopsy for the prediction groups'}
prog.gbm.preds <- ifelse(predict(models$ProgressedToTreatment$`CR + RSI lesion signal`, type = 'prob')[, 'yes'] > optimal.thresholds$ProgressedToTreatment$`CR + RSI lesion signal`, 1, 0)

progression.surv.dx.valid <- do.call(
    what = survival::Surv,
    args = surv.format(biodb.valid$DaysDxToProgression, biodb.valid$DaysDxToLastReview)
    );

patient.groups <- as.factor(prog.gbm.preds[!is.na(progression.surv.dx.valid)]);
levels(patient.groups) <- c('No progression prediction', 'Predict progression');
do.call(
  what = BoutrosLab.plotting.survival::create.km.plot,
  args = c(
    km.arguments,
    list(
      # Is this right to remove the missing values?
      survival.object = progression.surv.dx.valid[!is.na(progression.surv.dx.valid)],
      patient.groups = patient.groups,
      main.cex = 1.6,
      main = 'Overall Days-to-Progression from Diagnosis',
      xlab.label = 'Days to progression since diagnosis',
      ylab.label = 'Progression-free survival',
      filename = here('euro_urology/figures/km_dx-to-progression.tiff')
      )
    )
  )
```

Cross-validation results. Something seems off here.
```{r}
cv.model.name <- 'CR + RSI lesion signal'
cv.best.preds <- with(models$ProgressedToTreatment[[cv.model.name]], merge(pred, bestTune));
cv.biodb.valid <- biodb.valid[cv.best.preds$rowIndex, ];
  
progression.surv.dx.valid <- do.call(
    what = survival::Surv,
    args = surv.format(cv.biodb.valid$DaysDxToProgression, cv.biodb.valid$DaysDxToLastReview)
    );

cv.patient.groups <- as.factor(ifelse(cv.best.preds$yes > optimal.thresholds$ProgressedToTreatment[[cv.model.name]], 'yes', 'no'))
levels(cv.patient.groups) <- c('No upgrade prediction', 'Predict upgrade');

survdiff(progression.surv.dx.valid ~ cv.patient.groups)
coxph.model <- coxph(progression.surv.dx.valid ~ cv.patient.groups)
sum.coxph.model <- summary(coxph.model)

cox.ci <- sum.coxph.model$conf.int[c(1, 3, 4)]
do.call(sprintf, c("%.2f (%.2f, %.2f)", as.list(cox.ci)))
sum.coxph.model$waldtest['pvalue']
```

## Variable Importance Plot
```{r}
alt.model <- readRDS(here('models/gbm_BiopsyUpgraded_PR-AUC_9999_reduced_both_model.RDS'))
reduced.var.imp <- var.imp(alt.model)
# reduced.var.imp <- var.imp(models$BiopsyUpgraded$`CR + RSI lesion signal and PI-RADS`)
reduced.var.imp <- reduced.var.imp[order(reduced.var.imp$Overall, decreasing = FALSE), ]
reduced.var.imp$labels <- col.labels[reduced.var.imp$variable]
reduced.var.imp$labels <- factor(reduced.var.imp$labels, levels = reduced.var.imp$labels)

create.barplot(
  labels ~ Overall,
  data = reduced.var.imp,
  plot.horizontal = TRUE,
  ylab.label = NULL,
  xlab.label = 'GBM Variable Importance',
  width = 14,
  height = 16,
  resolution = 300,
  ylab.axis.padding = 20,
  filename = here::here('euro_urology/figures/variable_importance_without_mips.tiff')
  )
```

## Cox PH
```{r}
upgrade.surv.valid <- do.call(
    what = survival::Surv,
    args = surv.format(biodb$DaysDxToUpgrade, biodb$DaysDxToLastReview)
    );

baseline_vars <- c("Age", "BMI", "Race", "Ethnicity", "SOCPSA", "PercentFreePSA", 
"PHI", "PCA3", "T2ERG")

model1_vars <-  c(baseline_vars, "RSIlesionPIRADS", "PSADensity")
model2_vars <- c(baseline_vars, "MiPSHighGradeCancerRisk", 
"GeneticRiskScore", "RSIlesionSignal", "PHIDensity")

cox_formula1 <- as.formula(paste0('upgrade.surv.valid ~', paste0(model1_vars, collapse = " + ")))
cox_formula2 <- as.formula(paste0('upgrade.surv.valid ~', paste0(model2_vars, collapse = " + ")))

model1 <- coxph(cox_formula1, data = biodb)
model2 <- coxph(cox_formula2, data = biodb)

logLik(model1)
logLik(model2)


model1
```
### Coxnet
```{r}
library(glmnet)

tte_vars <- c("Age", "BMI", "Race", "Ethnicity", "SOCPSA", "PercentFreePSA", 
"PHI", "PCA3", "T2ERG", "MiPSHighGradeCancerRisk", 
"GeneticRiskScore", "RSIlesionSignal", "ProstateVolume", 
"PHIDensity", "PSADensity")

lapply(biodb[,tte_vars], function(x) sum(is.na(x)))

cox_glmformula <- as.formula(paste0('upgrade.surv.valid ~', paste0(tte_vars, collapse = " + ")))
x <- model.matrix.lm(cox_glmformula, data = biodb, na.action = "na.pass")
y <- biodb$BiopsyUpgraded
cv.fit <- cv.glmnet(x, upgrade.surv.valid, family = "cox")
```
